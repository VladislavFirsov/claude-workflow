# Architecture Intent: claude-workflow

## Назначение документа

Этот документ фиксирует **архитектурный замысел проекта `claude-workflow`**:
- зачем он создаётся;
- какую фундаментальную проблему решает;
- чем он должен стать со временем;
- какие границы ответственности считаются инвариантными.

Документ предназначен для:
- архитектора;
- core-разработчиков runtime-слоя;
- принятия решений о дальнейшем развитии проекта.

Это **не документация по использованию** и **не продуктовый pitch**.

---

## 1. Что такое `claude-workflow` сейчас (фактическое состояние)

`claude-workflow` — это **рабочий прототип (PoC с завершённым core)**, состоящий из двух логически связанных частей:

### 1. Workflow-слой (Claude Code)
- Набор **sub-agents** (spec-analyst, spec-architect, spec-developer, validator и т.д.).
- Формализованный workflow разработки:
   - анализ → архитектура → реализация → валидация → тесты.
- Реализован как **slash-command** для Claude Code.
- Отвечает за *что делать и в каком порядке*.

### 2. Runtime-слой (Go sidecar)
- Отдельный **runtime-sidecar сервис**.
- Реализует:
   - DAG и зависимости;
   - планирование и параллельное исполнение;
   - маршрутизацию контекста;
   - учёт токенов и budget enforcement;
   - HTTP API.
- Core помечен как **Complete**, покрыт тестами.
- Реальный вызов LLM/инструментов **инжектируется извне** (runtime не привязан к конкретной модели).

Важно:
> Проект **уже реализует ключевые архитектурные идеи**,  
> но **ещё не является завершённым продуктом**.

---

## 2. Почему этот проект вообще создаётся (ключевая причина)

Проект не возник из идеи «сделать ещё один агентный фреймворк».

Он возник из **структурной проблемы**, наблюдаемой на практике:

> LLM-системы очень быстро перестают быть “скриптами”  
> и превращаются в **распределённые системы без runtime-дисциплины**.

### Симптомы проблемы
- рост стоимости нелинеен и плохо объясним;
- параллельные агенты дублируют контекст;
- порядок выполнения влияет на результат;
- поведение сложно воспроизвести;
- человек становится “message bus” между агентами.

Эта проблема:
- **не решается промтами**;
- **не решается best practices**;
- **не решается на уровне workflow-DSL**.

Это **runtime-проблема**, а не проблема логики.

---

## 3. Зачем существует `claude-workflow` (суть проекта)

### Короткая формулировка

> `claude-workflow` существует, чтобы **отделить описание LLM-процесса  
> от его исполнения** и сделать это исполнение **управляемым, предсказуемым и воспроизводимым**.

---

## 4. Что является ядром проекта (инвариант)

### Архитектурный инвариант

`claude-workflow` — это **execution & governance runtime**, а не:

- UI;
- SaaS;
- агент “для пользователей”;
- фреймворк для написания промтов.

### Его фундаментальная функция

> **Быть runtime-слоем для сложных LLM-workflow,  
> где execution — это управляемый ресурс.**

---

## 5. Граница ответственности проекта

### Проект ОТВЕЧАЕТ за:
- оркестрацию шагов (DAG, зависимости);
- параллельное исполнение;
- маршрутизацию и изоляцию контекста;
- учёт и ограничение стоимости;
- execution-policy (что разрешено / запрещено);
- воспроизводимость и аудит.

### Проект НЕ ОТВЕЧАЕТ за:
- UX и интерфейсы;
- бизнес-логику;
- выбор LLM-провайдера;
- качество генерации;
- инструменты (IDE, GitHub, CI).

Это жёсткая граница.  
Нарушение её размывает проект.

---

## 6. Почему workflow-слой (sub-agents) важен, но не главный

Workflow-слой:
- демонстрирует **реальный use-case**;
- служит **dogfooding** для runtime;
- позволяет проверять архитектурные гипотезы.

Но стратегически:

> Workflow — **клиент runtime**,  
> а runtime — **ценность проекта**.

---

## 7. Во что проект должен эволюционировать

### Целевое состояние (north star)

`claude-workflow` должен стать:

> **универсальным runtime-sidecar’ом  
> для сложных LLM-workflow и агентных систем**,  
> независимо от конкретного фреймворка или модели.

Характеристики:
- self-hosted;
- contracts-first;
- model-agnostic;
- workflow-agnostic;
- ориентирован на команды, а не на одиночных пользователей.

---

## 8. Как это связано с CLI-оркестрацией (Claude / Codex)

CLI-оркестрация:
- не является отдельным продуктом;
- является **частным случаем использования runtime**.

Текущий ручной процесс:
- Claude пишет план и код;
- Codex делает ревью;
- человек маршрутизирует.

Этот кейс:
- идеально ложится на архитектуру runtime;
- демонстрирует, зачем нужен execution-контроль;
- служит проверкой, что runtime работает вне API-мира.

---

## 9. Критерии архитектурного успеха проекта

Проект движется в правильном направлении, если:

- runtime можно использовать без Claude Code;
- workflow можно переписать, не меняя runtime;
- execution-policy задаётся явно и enforce’ится;
- человек перестаёт быть message bus;
- runtime остаётся простым и объяснимым.

---

## 10. Ключевая мысль для архитектора

> `claude-workflow` — это не про агентов.  
> Это про **дисциплину исполнения LLM-процессов**.

Все архитектурные решения должны проверяться вопросом:

> *Помогает ли это сделать execution более управляемым,  
> или это просто добавляет “умности”?*

Если второе — это вне цели проекта.
